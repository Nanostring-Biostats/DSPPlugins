#' \item The output of the optim() call
#' }
#' @export
estimatescaling <- function(mat, bg, quant = 0.8) {
# step 1: quantile-normalize as a starting point:
if (is.numeric(quant)) {
s0 = apply(pmax(mat - bg, 0), 2, quantile, quant)
}
else {
s0 = rep(1, ncol(mat))
}
# step 2: weight genes by how much of a vote they should have:
wts = find_stable_genes(norm = sweep(mat, 2, s0, "/"),
bg = sweep(bg, 2, s0, "/"))
# sep 3: optimize:
mat = mat; bg = bg; wts = wts
fn = function(log.s, mat, bg, wts) {
# get bg-subtracted and scaled expression:
norm = pmax(mat - bg, 0) / exp(log.s)
# get epsilon, a small non-zero value:
eps = min(norm[norm > 0]) / 2
# score log-scale variance of each gene:
stat = apply(log2(norm + eps), 1, var)
#stat = apply(log2(norm + eps), 1, quantile, 0.75) - apply(log2(norm + eps), 1, quantile, 0.25)
return(sum(stat * wts) / sum(wts))
}
op = optim(par = log(s0), fn = fn, mat = mat, bg = bg, wts = wts)
out = list()
out$s = exp(op$par)
out$op = op
return(out)
}
temp = estimatescaling(mat = raw, bg = bg, quant = 0.8)
plot(temp$s, temp0$s)
# how it compares to quantiles:
par(mfrow = c(3,3))
for (q in c(seq(0.5, .9, 0.1), 0.95, 0.99, 0.995)) {
plot(temp$s, apply(raw, 2, quantile, q), log = "xy", main = q,
pch = 16, col = rgb(0,0,1,0.5), cex = 0.75)
abline(0,1)
}
plot(temp$s, temp0$s, log = "xy")
temp$wts
names(temp)
#' @param bg Matrix of expected background counts, on the scale of mat.
#' @param quant Quantile to be used in first round scaling of data.
#'   If you've already thoughtfully normalized mat, then set this to NULL,
#'   and the function will perform no additional up-front scaling.
#' @return A list with two elements:
#' \itemize{
#' \item A vector of scaling factors
#' \item The output of the optim() call
#' }
#' @export
estimatescaling <- function(mat, bg, quant = 0.8) {
# step 1: quantile-normalize as a starting point:
if (is.numeric(quant)) {
s0 = apply(pmax(mat - bg, 0), 2, quantile, quant)
}
else {
s0 = rep(1, ncol(mat))
}
# step 2: weight genes by how much of a vote they should have:
wts = find_stable_genes(norm = sweep(mat, 2, s0, "/"),
bg = sweep(bg, 2, s0, "/"))
# sep 3: optimize:
mat = mat; bg = bg; wts = wts
#fn = function(log.s, mat, bg, wts) {
fn = function(s, mat, bg, wts) {
# get bg-subtracted and scaled expression:
#norm = pmax(mat - bg, 0) / exp(log.s)
norm = pmax(mat - bg, 0) / s
# get epsilon, a small non-zero value:
eps = min(norm[norm > 0]) / 2
# score log-scale variance of each gene:
stat = apply(log2(norm + eps), 1, var)
#stat = apply(log2(norm + eps), 1, quantile, 0.75) - apply(log2(norm + eps), 1, quantile, 0.25)
return(sum(stat * wts) / sum(wts))
}
#op = optim(par = log(s0), fn = fn, mat = mat, bg = bg, wts = wts)
op = optim(par = s, fn = fn, mat = mat, bg = bg, wts = wts)
out = list()
#out$s = exp(op$par)
out$s = op$par
out$wts = wts
out$op = op
return(out)
}
temp1 = temp
temp = estimatescaling(mat = raw, bg = bg, quant = 0.8)
# how it compares to quantiles:
par(mfrow = c(3,3))
for (q in c(seq(0.5, .9, 0.1), 0.95, 0.99, 0.995)) {
plot(temp$s, apply(raw, 2, quantile, q), log = "xy", main = q,
pch = 16, col = rgb(0,0,1,0.5), cex = 0.75)
abline(0,1)
}
temp$wts
hist(temp$wts)
#' @param bg Matrix of expected background counts, on the scale of mat.
#' @param quant Quantile to be used in first round scaling of data.
#'   If you've already thoughtfully normalized mat, then set this to NULL,
#'   and the function will perform no additional up-front scaling.
#' @return A list with two elements:
#' \itemize{
#' \item A vector of scaling factors
#' \item The output of the optim() call
#' }
#' @export
estimatescaling <- function(mat, bg, quant = 0.8) {
# step 1: quantile-normalize as a starting point:
if (is.numeric(quant)) {
s0 = apply(pmax(mat - bg, 0), 2, quantile, quant)
}
else {
s0 = rep(1, ncol(mat))
}
# step 2: weight genes by how much of a vote they should have:
wts = find_stable_genes(norm = sweep(mat, 2, s0, "/"),
bg = sweep(bg, 2, s0, "/"))
# sep 3: optimize:
mat = mat; bg = bg; wts = wts
#fn = function(log.s, mat, bg, wts) {
fn = function(s, mat, bg, wts) {
# get bg-subtracted and scaled expression:
#norm = pmax(mat - bg, 0) / exp(log.s)
norm = pmax(mat - bg, 0) / s
# get epsilon, a small non-zero value:
eps = min(norm[norm > 0]) / 2
# score log-scale variance of each gene:
stat = apply(log2(norm + eps), 1, var)
#stat = apply(log2(norm + eps), 1, quantile, 0.75) - apply(log2(norm + eps), 1, quantile, 0.25)
return(sum(stat * wts) / sum(wts))
}
#op = optim(par = log(s0), fn = fn, mat = mat, bg = bg, wts = wts)
op = optim(par = s0, fn = fn, mat = mat, bg = bg, wts = wts)
out = list()
#out$s = exp(op$par)
out$s = op$par
out$wts = wts
out$op = op
return(out)
}
temp = estimatescaling(mat = raw, bg = bg, quant = 0.8)
# how it compares to quantiles:
par(mfrow = c(3,3))
for (q in c(seq(0.5, .9, 0.1), 0.95, 0.99, 0.995)) {
plot(temp$s, apply(raw, 2, quantile, q), log = "xy", main = q,
pch = 16, col = rgb(0,0,1,0.5), cex = 0.75)
abline(0,1)
}
# diagnostics/ qcs on procedure:
plot(apply(norm, 2, mean), apply(norm, 2, sd),
cex = temp$wts)
# diagnostics/ qcs on procedure:
plot(apply(norm, 2, mean), apply(norm, 2, sd), log = "xy",
cex = temp$wts, pch = 16, col = rgb(0,0,0,0.5))
dev.off()
# diagnostics/ qcs on procedure:
plot(apply(norm, 2, mean), apply(norm, 2, sd), log = "xy",
cex = temp$wts + 0.1, pch = 16, col = rgb(0,0,1,0.5))
temp$wts
# diagnostics/ qcs on procedure:
plot(apply(norm, 2, mean), apply(norm, 2, sd), log = "xy",
cex = temp$wts[colnames(norm)] + 0.1, pch = 16, col = rgb(0,0,1,0.5))
# apply the scaling factor:
norm = sweep(raw, 2, temp$s, "/") * mean(temp$s)
raw.bgsub = pmax(raw - bg, 0)
norm.bgsub = sweep(raw.bgsub, 2, temp$s, "/") * mean(temp$s)
# diagnostics/ qcs on procedure:
plot(apply(norm, 2, mean), apply(norm, 2, sd), log = "xy",
cex = temp$wts[colnames(norm)] + 0.1, pch = 16, col = rgb(0,0,1,0.5))
colnames(norm)
# diagnostics/ qcs on procedure:
plot(apply(norm, 2, mean), apply(norm, 2, sd), log = "xy",
cex = temp$wts[rownames(norm)] + 0.1, pch = 16, col = rgb(0,0,1,0.5))
# diagnostics/ qcs on procedure:
plot(apply(norm, 1, mean), apply(norm, 1, sd), log = "xy",
cex = temp$wts[rownames(norm)] + 0.1, pch = 16, col = rgb(0,0,1,0.5))
# diagnostics/ qcs on procedure:
plot(apply(norm, 1, mean), apply(norm, 1, sd), log = "xy",
cex = temp$wts[rownames(norm)] + 0.1, pch = 16, col = rgb(0,0,1,0.25))
plot(apply(log2(norm), 1, mean), apply(log2(norm), 1, sd),
cex = temp$wts[rownames(norm)] + 0.1, pch = 16, col = rgb(0,0,1,0.25))
library(pheatmap)
an = data.frame(wts = temp$wts)
rownames(an) = names(wts)
pheatmap(sweep(norm.bgsub, 1, apply(norm.bgsub, 1, max), "/"),
col = colorRampPalette(c("white","darkblue"))(100),
annotation_row = an)
pheatmap(sweep(norm.bgsub, 1, apply(norm.bgsub, 1, max) + 0.1, "/"),
col = colorRampPalette(c("white","darkblue"))(100),
annotation_row = an)
pheatmap(sweep(norm.bgsub, 1, apply(norm.bgsub, 1, max) + 0.1, "/"),
col = colorRampPalette(c("white","darkblue"))(100),
annotation_row = an)
head(annot)
,
pheatmap(sweep(norm.bgsub, 1, apply(norm.bgsub, 1, max) + 0.1, "/"),
col = colorRampPalette(c("white","darkblue"))(100),
annotation_row = an,
annotation_col = annot[, c("tissue", "aoi_type")],
show_rownames = F, show_colnames = F)
plot(apply(log2(norm), 1, mean), apply(log2(norm), 1, sd),
cex = temp$wts[rownames(norm)] + 0.1, pch = 16, col = rgb(0,0,1,0.25))
plot(apply(log2(norm), 1, mean), apply(log2(norm), 1, sd),
cex = temp$wts[rownames(norm)]/2 + 0.1, pch = 16, col = rgb(0,0,1,0.25))
# how it compares to quantiles:
par(mfrow = c(3,3))
for (q in c(seq(0.5, .9, 0.1), 0.95, 0.99, 0.995)) {
plot(temp$s, apply(raw, 2, quantile, q), log = "xy", main = q,
pch = 16, col = rgb(0,0,1,0.5), cex = 0.75)
abline(0,1)
}
plot(temp$s, raw["NegProbe", ], log = "xy", main = q,
pch = 16, col = rgb(1,0,0,0.5), cex = 0.75)
abline(0,1)
setwd("C:/Users/pdanaher/Box Sync/DSP datasets/Mel OICR")
rm(list = ls())
library(SpatialDecon)
library(pheatmap)
library(scales)
library(RColorBrewer)
library(readxl)
raw0 = as.data.frame(read_xlsx( "3_Biological_probe_QC.xlsx", "TargetCountMatrix"))
raw = as.matrix(raw0[, -1])
rownames(raw) = raw0[, 1]
rm(raw0)
annot = as.data.frame(read_xlsx( "3_Biological_probe_QC.xlsx", "SegmentProperties"))
annot$AOISurfaceArea = as.numeric(annot$AOISurfaceArea)
annot$AOINucleiCount = as.numeric(annot$AOINucleiCount)
rownames(annot) = annot$SegmentDisplayName
stopifnot(identical(rownames(annot), colnames(raw)))
pannot = as.data.frame(read_xlsx( "3_Biological_probe_QC.xlsx", "TargetProperties"))
# assign colors:
cols = list()
cols[["SegmentLabel"]] = c("chartreuse3", "darkblue", "darkred")
names(cols[["SegmentLabel"]]) = c("Geometric Segment", "TME", "Tumor")
cols[["Scan_ID_1"]] = brewer.pal(4, "Dark2")
names(cols[["Scan_ID_1"]]) = unique(annot$Scan_ID_1)
# calc norm factors:
negnames = rownames(raw)[grepl("Neg", rownames(raw))]
annot$neg = colMeans(raw[negnames, , drop = F])
annot$q3 = apply(raw, 2, quantile, 0.75)
annot$q9 = apply(raw, 2, quantile, 0.9)
annot$signal.bg.ratio = log2(annot$q9 / annot$neg)
# explore norm factors:
for (name in names(cols)) {
pairs(annot[, c("q3", "q9", "neg", "AOISurfaceArea")], pch = 16, col = alpha(cols[[name]][annot[, name]], 0.5), log = "xy")
}
for (name in names(cols)) {
plot(annot$q9, annot$neg, pch = 16, col = alpha(cols[[name]][annot[, name]], 0.5), log = "xy")
}
hist(log2(annot$q9), breaks = 40)
thresh = 3
abline(v = thresh, col = 2)
keep = annot$q9 > 2^thresh
# ad hoc: remove the weird slide:
bad.scan.id = ""
keep[annot$Scan_ID_1 == bad.scan.id] = FALSE
keep.seg = keep
annot = annot[keep.seg, ]
raw = raw[, keep.seg]
keep
#### perform normalization ------------------------
norm = sweep(raw, 2, annot$q9, "/")
bg = derive_GeoMx_background(norm = norm, probepool = pannot$ProbePool, negnames = negnames)
bgsub = pmax(norm - bg, 0)
snr = sweep(raw, 2, annot$neg, "/")
keep.gene.tme = rownames(snr)[(rowSums(snr[, annot$SegmentLabel == "TME"] > 2) > 5) |
(rowSums(snr[, annot$SegmentLabel == "TME"] > 1.5) > 10)]
keep.gene.tumor = rownames(snr)[(rowSums(snr[, annot$SegmentLabel == "Tumor"] > 2) > 5) |
(rowSums(snr[, annot$SegmentLabel == "Tumor"] > 1.5) > 10)]
keep.gene = intersect(keep.gene.tumor, keep.gene.tme)
length(keep.gene)
pc = prcomp(log2(t(norm[keep.gene, ])))$x
for (name in names(cols)) {
pairs(pc[, 1:3], pch = 16, cex = 1.5, col = alpha(cols[[name]][annot[, name]], 0.5))
}
x100 = round(100 * (log2(annot$neg) - min(log2(annot$neg))) / (max(log2(annot$neg)) - min(log2(annot$neg))))
pairs(pc[, 1:3], pch = 16, cex = 1.5,
main = "Background level",
col = alpha(colorRampPalette(c("blue", "red"))(100)[x100], 0.5))
x100 = round(1 + 100 * (annot$signal.bg.ratio - min(annot$signal.bg.ratio)) / (max(annot$signal.bg.ratio) - min(annot$signal.bg.ratio )))
pairs(pc[, 1:3], pch = 16, cex = 1.5,
main = "Background/signal ratio",
col = alpha(colorRampPalette(c("red", "blue"))(101)[x100], 0.5))
res = spatialdecon(norm = norm,
bg = bg,
X = safeTME,
is_pure_tumor = annot$SegmentLabel == "Tumor",
n_tumor_clusters = 10,
cell_counts = as.numeric(annot$AOINucleiCount))
pheatmap(pmin(res$beta, 0.5), col = viridis_pal(option = "B")(100),
annotation_col = annot[, names(cols)],
annotation_colors = cols,
show_colnames = F)
p1 = pheatmap(res$beta[!grepl("tumor", rownames(res$beta)), annot$SegmentLabel == "TME"], col = viridis_pal(option = "B")(100),
annotation_col = annot[, names(cols)],
annotation_colors = cols,
show_colnames = F)
pheatmap(res$beta[!grepl("tumor", rownames(res$beta)), annot$SegmentLabel == "Tumor"], col = viridis_pal(option = "B")(100),
annotation_col = annot[, names(cols)],
annotation_colors = cols,
show_colnames = F)
ind.tme = annot$SegmentLabel == "TME"
immcells = rownames(res$beta)[!grepl("tumor", rownames(res$beta))]
TIL_barplot(res$beta[immcells, ind.tme][, p1$tree_col$order], ylab = "Beta")
legend("topright", fill = rev(cellcols[immcells]), legend = rev(immcells))
TIL_barplot(res$cell.counts$cell.counts[immcells, ind.tme][, p1$tree_col$order], ylab = "Counts")
legend("topright", fill = rev(cellcols[immcells]), legend = rev(immcells))
dev.off()
TIL_barplot(res$beta[immcells, ind.tme][, p1$tree_col$order], ylab = "Beta")
legend("topright", fill = rev(cellcols[immcells]), legend = rev(immcells))
TIL_barplot(res$cell.counts$cell.counts[immcells, ind.tme][, p1$tree_col$order], ylab = "Counts")
legend("topright", fill = rev(cellcols[immcells]), legend = rev(immcells))
TIL_barplot(res$cell.counts$cells.per.100[immcells, ind.tme][, p1$tree_col$order], ylab = "Counts")
legend("topright", fill = rev(cellcols[immcells]), legend = rev(immcells))
pc = prcomp(log2(t(norm[keep.gene, ])))$x
for (name in names(cols)) {
pairs(pc[, 1:3], pch = 16, cex = 1.5, col = alpha(cols[[name]][annot[, name]], 0.5))
}
cols
table(annot$Scan_ID_1)
plot(pc[, 3])
plot(pc[, 3], res$beta[1, ])
x100 = round(1 + 100 * (annot$signal.bg.ratio - min(annot$signal.bg.ratio)) / (max(annot$signal.bg.ratio) - min(annot$signal.bg.ratio )))
pairs(pc[, 1:3], pch = 16, cex = 1.5,
main = "Background/signal ratio",
col = alpha(colorRampPalette(c("red", "blue"))(101)[x100], 0.5))
pc = prcomp(log2(t(norm[keep.gene, ])))$x
for (name in names(cols)) {
pairs(pc[, 1:3], pch = 16, cex = 1.5, col = alpha(cols[[name]][annot[, name]], 0.5))
}
pairs(pc[, 1:3], pch = 16, cex = 1.5,
main = "Background/signal ratio",
col = alpha(colorRampPalette(c("red", "blue"))(101)[x100], 0.5))
TIL_barplot(res$beta[immcells, ind.tme][, p1$tree_col$order], ylab = "Beta")
setwd("~/Extensions")
##### this script contains the code used to build the package.
rm(list=ls())
library("devtools")
library(roxygen2)
setwd("SpatialDecon")
devtools::document()
devtools::document()
devtools::test() # run unit tests
devtools::check()
library(ComplexHeatmap)
?Heatmap
setwd("~/plugins/DSPPlugins/build decon plugin")
### TO DO:
#- test it out (temporarily overwriting the load X with a load safeTME command)
#-
library("styler")
?use_tidy_style
source('~/plugins/DSPPlugins/build decon plugin/build spatialdecon plugin.R', echo=TRUE)
### TO DO:
#- test it out (temporarily overwriting the load X with a load safeTME command)
#-
library("styler")
rm(list = ls())
# directory of spatialdecon library:
sdpath = "C:\\Users\\pdanaher\\Documents\\Extensions\\SpatialDecon"
# directory of cell profiles library:
libpath = "C:\\Users\\pdanaher\\Documents\\Extensions\\cell-profile-library"
# empty text:
zz = list()
#### copy main() function (includes arguments):
temp = readChar("main.R", file.info("main.R")$size)
zz[[length(zz) + 1]] = temp
#### copy all R functions from spatialdecon
# point to the spatialdecon library:
sdecondir = "C:\\Users\\pdanaher\\Documents\\Extensions\\SpatialDecon\\R"
# and copy all its R functions:
for (name in dir(sdecondir)) {
fname = paste0(sdecondir, "/", name)
temp = readChar(fname, file.info(fname)$size)
# remove boilerplate
temp = gsub("\\# SpatialDecon: mixed cell deconvolution for spatial and/or bulk gene expression data\r\n", "", temp)
temp = gsub("\\# Copyright \\(C\\) 2020, NanoString Technologies, Inc\\.\r\n", "", temp)
temp = gsub("\\#    This program is free software\\: you can redistribute it and\\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or \\(at your option\\) any later version\\.\r\n", "", temp)
temp = gsub("\\#    This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE\\.  See the GNU General Public License for more details\\.\r\n", "", temp)
temp = gsub("\\#    You should have received a copy of the GNU General Public License along with this program.  If not, see https://www.gnu.org/licenses/.\r\n\\# Contact us:\r\n# NanoString Technologies, Inc\\.\r\n", "", temp)
temp = gsub("\\# 530 Fairview Avenue N\r\n", "", temp)
temp = gsub("\\# Seattle, WA 98109\r\n", "", temp)
temp = gsub("\\# Tel: \\(888\\) 358-6266\r\n", "", temp)
temp = gsub("\\# pdanaher@nanostring.com", "", temp)
zz[[length(zz) + 1]] = temp
}
#### copy data:
temp = readChar("spatialdecon data.R", file.info("spatialdecon data.R")$size)
zz[[length(zz) + 1]] = temp
cat("", file = "SpatialDecon_plugin.R")
for (i in 1:length(zz)) {
cat(zz[[i]], file = "SpatialDecon_plugin.R", append = T, sep = "\n")
}
# format:
use_tidy_style("SpatialDecon_plugin.R")
# format:
use_tidy_style("SpatialDecon_plugin.R", strict = FALSE)
# format:
use_tidy_style(path = "SpatialDecon_plugin.R", strict = FALSE)
?cat
source('~/plugins/DSPPlugins/build decon plugin/build spatialdecon plugin.R', echo=TRUE)
?print
print("", file = "SpatialDecon_plugin.R")
cat("", file = "SpatialDecon_plugin.R")
for (i in 1:length(zz)) {
cat(zz[[i]], file = "SpatialDecon_plugin.R", append = T, sep = " ", fill = TRUE)
}
?cat
file.copy(from = "SpatialDecon_plugin.R", "final_script/SpatialDecon_plugin.R")
setwd("final_script/")
# format:
use_tidy_style()
### TO DO:
#- test it out (temporarily overwriting the load X with a load safeTME command)
#-
library("styler")
rm(list = ls())
# directory of spatialdecon library:
sdpath <- "C:\\Users\\pdanaher\\Documents\\Extensions\\SpatialDecon"
# directory of cell profiles library:
libpath <- "C:\\Users\\pdanaher\\Documents\\Extensions\\cell-profile-library"
# empty text:
zz <- list()
#### copy main() function (includes arguments):
temp <- readChar("main.R", file.info("main.R")$size)
zz[[length(zz) + 1]] <- temp
#### copy all R functions from spatialdecon
# point to the spatialdecon library:
sdecondir <- "C:\\Users\\pdanaher\\Documents\\Extensions\\SpatialDecon\\R"
# and copy all its R functions:
for (name in dir(sdecondir)) {
fname <- paste0(sdecondir, "/", name)
temp <- readChar(fname, file.info(fname)$size)
# remove boilerplate
temp <- gsub("\\# SpatialDecon: mixed cell deconvolution for spatial and/or bulk gene expression data\r\n", "", temp)
temp <- gsub("\\# Copyright \\(C\\) 2020, NanoString Technologies, Inc\\.\r\n", "", temp)
temp <- gsub("\\#    This program is free software\\: you can redistribute it and\\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or \\(at your option\\) any later version\\.\r\n", "", temp)
temp <- gsub("\\#    This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE\\.  See the GNU General Public License for more details\\.\r\n", "", temp)
temp <- gsub("\\#    You should have received a copy of the GNU General Public License along with this program.  If not, see https://www.gnu.org/licenses/.\r\n\\# Contact us:\r\n# NanoString Technologies, Inc\\.\r\n", "", temp)
temp <- gsub("\\# 530 Fairview Avenue N\r\n", "", temp)
temp <- gsub("\\# Seattle, WA 98109\r\n", "", temp)
temp <- gsub("\\# Tel: \\(888\\) 358-6266\r\n", "", temp)
temp <- gsub("\\# pdanaher@nanostring.com", "", temp)
# remove package references:
temp <- gsub("SpatialDecon::", "", temp)
zz[[length(zz) + 1]] <- temp
}
#### copy data:
temp <- readChar("spatialdecon data.R", file.info("spatialdecon data.R")$size)
zz[[length(zz) + 1]] <- temp
cat("", file = "SpatialDecon_plugin.R")
for (i in 1:length(zz)) {
cat(zz[[i]], file = "SpatialDecon_plugin.R", append = T, sep = " ", fill = TRUE)
}
setwd("..")
### TO DO:
#- test it out (temporarily overwriting the load X with a load safeTME command)
#-
library("styler")
rm(list = ls())
# directory of spatialdecon library:
sdpath <- "C:\\Users\\pdanaher\\Documents\\Extensions\\SpatialDecon"
# directory of cell profiles library:
libpath <- "C:\\Users\\pdanaher\\Documents\\Extensions\\cell-profile-library"
# empty text:
zz <- list()
#### copy main() function (includes arguments):
temp <- readChar("main.R", file.info("main.R")$size)
zz[[length(zz) + 1]] <- temp
#### copy all R functions from spatialdecon
# point to the spatialdecon library:
sdecondir <- "C:\\Users\\pdanaher\\Documents\\Extensions\\SpatialDecon\\R"
# and copy all its R functions:
for (name in dir(sdecondir)) {
fname <- paste0(sdecondir, "/", name)
temp <- readChar(fname, file.info(fname)$size)
# remove boilerplate
temp <- gsub("\\# SpatialDecon: mixed cell deconvolution for spatial and/or bulk gene expression data\r\n", "", temp)
temp <- gsub("\\# Copyright \\(C\\) 2020, NanoString Technologies, Inc\\.\r\n", "", temp)
temp <- gsub("\\#    This program is free software\\: you can redistribute it and\\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or \\(at your option\\) any later version\\.\r\n", "", temp)
temp <- gsub("\\#    This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE\\.  See the GNU General Public License for more details\\.\r\n", "", temp)
temp <- gsub("\\#    You should have received a copy of the GNU General Public License along with this program.  If not, see https://www.gnu.org/licenses/.\r\n\\# Contact us:\r\n# NanoString Technologies, Inc\\.\r\n", "", temp)
temp <- gsub("\\# 530 Fairview Avenue N\r\n", "", temp)
temp <- gsub("\\# Seattle, WA 98109\r\n", "", temp)
temp <- gsub("\\# Tel: \\(888\\) 358-6266\r\n", "", temp)
temp <- gsub("\\# pdanaher@nanostring.com", "", temp)
# remove package references:
temp <- gsub("SpatialDecon::", "", temp)
zz[[length(zz) + 1]] <- temp
}
#### copy data:
temp <- readChar("spatialdecon data.R", file.info("spatialdecon data.R")$size)
zz[[length(zz) + 1]] <- temp
cat("", file = "SpatialDecon_plugin.R")
for (i in 1:length(zz)) {
cat(zz[[i]], file = "SpatialDecon_plugin.R", append = T, sep = " ", fill = TRUE)
}
#setwd("final_script/")
# format:
use_tidy_style()
rm(list = ls())
source("SpatialDecon_plugin.txt")
# load test data:
load("test data/save Rdata result - 2020-05-04 18_14_53.79 export.RData")
# run it:
main(dataset = dataset, segmentAnnotations = segmentAnnotations, targetAnnotations = targetAnnotations, outputFolder = "testresults")
head(targetAnnotations)
colnames(targetAnnotations)
