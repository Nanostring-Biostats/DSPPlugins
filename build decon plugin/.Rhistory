tissue.order = NULL,
tissuecols = NULL,
tissuecols.alpha = 0.2,
rescale = TRUE,
cex = 3, col = cols[[varname]][segmentAnnotations[use, varname]],
nrow = NULL, rowind = NULL, colind = NULL,
expansion = 1.2,
main = cell)
for (name in names(sp$boundaries)) {
text(x = median(range(sp$boundaries[[name]]$x)),
y = max(sp$boundaries[[name]]$y),
name)
}
}
dev.off()
}
# proportion spaceplots
for (atype in unique(aoitype)) {
pdf(file = file.path(outputFolder, paste0("spaceplots-proportion-subset-", atype, "-colorby-", varname, ".pdf"), fsep = .Platform$file.sep))
use = aoitype == atype
for (cell in cells.to.plot) {
sp = spaceplot(x = segmentAnnotations[use, xpositionname],
y = segmentAnnotations[use, ypositionname],
z = res$prop_of_nontumor[cell, use],
tissue = segmentAnnotations[use, tissueidname],
tissue.order = NULL,
tissuecols = NULL,
tissuecols.alpha = 0.2,
rescale = TRUE,
cex = 3, col = cols[[varname]][segmentAnnotations[use, varname]],
nrow = NULL, rowind = NULL, colind = NULL,
expansion = 1.2,
main = cell)
for (name in names(sp$boundaries)) {
text(x = median(range(sp$boundaries[[name]]$x)),
y = max(sp$boundaries[[name]]$y),
name)
}
}
dev.off()
}
}
atype
use = aoitype == atype
sp = spaceplot(x = segmentAnnotations[use, xpositionname],
y = segmentAnnotations[use, ypositionname],
z = res$beta[cell, use],
tissue = segmentAnnotations[use, tissueidname],
tissue.order = NULL,
tissuecols = NULL,
tissuecols.alpha = 0.2,
rescale = TRUE,
cex = 3, col = cols[[varname]][segmentAnnotations[use, varname]],
nrow = NULL, rowind = NULL, colind = NULL,
expansion = 1.2,
main = cell)
cells.to.plot
for (cell in cells.to.plot) {
use = aoitype == atype
sp = spaceplot(x = segmentAnnotations[use, xpositionname],
y = segmentAnnotations[use, ypositionname],
z = res$beta[cell, use],
tissue = segmentAnnotations[use, tissueidname],
tissue.order = NULL,
tissuecols = NULL,
tissuecols.alpha = 0.2,
rescale = TRUE,
cex = 3, col = cols[[varname]][segmentAnnotations[use, varname]],
nrow = NULL, rowind = NULL, colind = NULL,
expansion = 1.2,
main = cell)
for (name in names(sp$boundaries)) {
text(x = median(range(sp$boundaries[[name]]$x)),
y = max(sp$boundaries[[name]]$y),
name)
}
}
x
segmentAnnotations[use, ypositionname]
use
ypositionname
segmentAnnotations[use, ypositionname]
head(segmentAnnotations)
ypositionname
source('~/plugins/DSPPlugins/build decon plugin/build spatialdecon plugin.R', echo=TRUE)
rm(list = ls())
source("SpatialDecon_plugin.R")
load("test data/2.0.0.89 Dev1 M-275 NGS CTAx4.RData")
# run it:
main(
dataset = dataset,
segmentAnnotations = segmentAnnotations,
targetAnnotations = targetAnnotations,
outputFolder = "testresults"
)
sp = spaceplot(x = segmentAnnotations[use, xpositionname],
y = segmentAnnotations[use, ypositionname],
z = res$beta[cell, use],
tissue = segmentAnnotations[use, tissueidname],
tissue.order = NULL,
tissuecols = NULL,
tissuecols.alpha = 0.2,
rescale = TRUE,
cex = 3, col = cols[[varname]][segmentAnnotations[use, varname]],
nrow = NULL, rowind = NULL, colind = NULL,
expansion = 1.2,
main = cell)
cols
#### preliminaries ----------------------
dataset <- as.matrix(dataset)
# access cell profile matrix file:
X <- as.matrix(read.csv(cell_profile_filename, header = T, row.names = 1))
# parse merges:
merges.full <- NULL
if (length(merges) > 0) {
# initialize with 1:1 mapping:
merges.full <- list()
for (name in colnames(X)) {
merges.full[[name]] <- name
}
# add merges:
for (name in names(merges0)) {
# remove entries for cells specified by user and replace with their entries:
merges.full[merges[[name]]] <- NULL
merges.full[[name]] <- merges[[name]]
}
}
# parse nuclei column
cell_counts <- NULL
if (is.element(nuclei_count_column_name, colnames(segmentAnnotations))) {
cell_counts <- as.numeric(segmentAnnotations[, nuclei_count_column_name])
}
if (!is.element(nuclei_count_column_name, colnames(segmentAnnotations))) {
warning("The value entered for nuclei_count_column_name was not a column header in the segment annotations.
Results will not be output on the scale of cell counts; just in abundance scores and proportions.")
}
# parse pure tumor column
is_pure_tumor <- NULL
if (is.element(pure_tumor_column_name, colnames(segmentAnnotations))) {
is_pure_tumor <- segmentAnnotations[, pure_tumor_column_name] == "tumor"
is_pure_tumor <- replace(is_pure_tumor, is.na(is_pure_tumor), FALSE)
}
if (!is.element(pure_tumor_column_name, colnames(segmentAnnotations)) & (pure_tumor_column_name != "none")) {
warning("The value entered for pure_tumor_column_name was not a column header in the segment annotations.")
}
# format data for spatialdecon:
norm <- dataset[targetAnnotations$TargetGUID, segmentAnnotations$segmentID]
rownames(norm) <- targetAnnotations$TargetName
# calculate background:
bg <- derive_GeoMx_background(
norm = norm,
probepool = targetAnnotations$ProbePool,
negnames = targetAnnotations$TargetName[targetAnnotations$CodeClass == "Negative"]
)
#### run decon: ----------------------------------------
# decon:
res <- spatialdecon(
norm = norm,
bg = bg,
X = X,
is_pure_tumor = is_pure_tumor,
cell_counts = cell_counts,
cellmerges = merges.full
)
# parse the argument for variables to plot:
if (length(setdiff(variables_to_plot, colnames(segmentAnnotations))) > 0) {
warning(paste0(
"the variables_to_plot values",
paste0(setdiff(variables_to_plot, colnames(segmentAnnotations)), collapse = ", "),
" are not present in the segmentAnnotations"
))
}
variables_to_plot <- intersect(variables_to_plot, colnames(segmentAnnotations))
heatmapannot <- NULL
if (length(variables_to_plot) > 0) {
heatmapannot <- segmentAnnotations[, variables_to_plot, drop = FALSE]
rownames(heatmapannot) = colnames(res$beta)
#rownames(heatmapannot) <- segmentAnnotations$segmentDisplayName
}
# colors for variables_to_plot:
if (length(cols) == 0) {
cols <- assign_colors(segmentAnnotations[, variables_to_plot])
}
# show just the original cells, not tumor abundance estimates derived from the is.pure.tumor argument:
cells.to.plot <- intersect(rownames(res$beta), union(colnames(X), names(merges.full)))
# stratify on SegmentName if it has multiple levels:
#(assumption: SegmentName gives segment type, identifies the different kinds of AOIs that can share an ROI)
aoitype = rep("", nrow(segmentAnnotations))
if (is.element("SegmentName", colnames(segmentAnnotations))) {
if (length(unique(segmentAnnotations[, "SegmentName"])) > 1) {
aoitype = segmentAnnotations[, "SegmentName"]
aoitype = replace(aoitype, is.na(aoitype), "na")
}
}
varname = variables_to_plot[1]
atype = aoitype[1]
use = aoitype == atype
sp = spaceplot(x = segmentAnnotations[use, xpositionname],
y = segmentAnnotations[use, ypositionname],
z = res$beta[cell, use],
tissue = segmentAnnotations[use, tissueidname],
tissue.order = NULL,
tissuecols = NULL,
tissuecols.alpha = 0.2,
rescale = TRUE,
cex = 3, col = cols[[varname]][segmentAnnotations[use, varname]],
nrow = NULL, rowind = NULL, colind = NULL,
expansion = 1.2,
main = cell)
cell = "macrophages"
sp = spaceplot(x = segmentAnnotations[use, xpositionname],
y = segmentAnnotations[use, ypositionname],
z = res$beta[cell, use],
tissue = segmentAnnotations[use, tissueidname],
tissue.order = NULL,
tissuecols = NULL,
tissuecols.alpha = 0.2,
rescale = TRUE,
cex = 3, col = cols[[varname]][segmentAnnotations[use, varname]],
nrow = NULL, rowind = NULL, colind = NULL,
expansion = 1.2,
main = cell)
dev.off()
sp = spaceplot(x = segmentAnnotations[use, xpositionname],
y = segmentAnnotations[use, ypositionname],
z = res$beta[cell, use],
tissue = segmentAnnotations[use, tissueidname],
tissue.order = NULL,
tissuecols = NULL,
tissuecols.alpha = 0.2,
rescale = TRUE,
cex = 3, col = cols[[varname]][segmentAnnotations[use, varname]],
nrow = NULL, rowind = NULL, colind = NULL,
expansion = 1.2,
main = cell)
sp = spaceplot(x = segmentAnnotations[use, xpositionname],
y = segmentAnnotations[use, ypositionname],
z = res$prop_of_nontumor[cell, use],
tissue = segmentAnnotations[use, tissueidname],
tissue.order = NULL,
tissuecols = NULL,
tissuecols.alpha = 0.2,
rescale = TRUE,
cex = 3, col = cols[[varname]][segmentAnnotations[use, varname]],
nrow = NULL, rowind = NULL, colind = NULL,
expansion = 1.2,
main = cell)
res$prop_of_nontumor[cell, use]
sp = spaceplot(x = segmentAnnotations[use, xpositionname],
y = segmentAnnotations[use, ypositionname],
z = replace(res$prop_of_nontumor[cell, use], is.na(res$prop_of_nontumor[cell, use]), 0),
tissue = segmentAnnotations[use, tissueidname],
tissue.order = NULL,
tissuecols = NULL,
tissuecols.alpha = 0.2,
rescale = TRUE,
cex = 3, col = cols[[varname]][segmentAnnotations[use, varname]],
nrow = NULL, rowind = NULL, colind = NULL,
expansion = 1.2,
main = cell)
source('~/plugins/DSPPlugins/build decon plugin/build spatialdecon plugin.R', echo=TRUE)
rm(list = ls())
source("SpatialDecon_plugin.R")
load("test data/2.0.0.89 Dev1 M-275 NGS CTAx4.RData")
# run it:
main(
dataset = dataset,
segmentAnnotations = segmentAnnotations,
targetAnnotations = targetAnnotations,
outputFolder = "testresults"
)
?use_tidy_style
# setwd("final_script/")
# format:
library(styler)
?use_tidy_style
# setwd("final_script/")
# format:
library(usethis)
?use_tidy_style
file.copy(from = "SpatialDecon_plugin.R", "final_script/SpatialDecon_plugin.R")
setwd("final_script/")
# format:
library(usethis)
use_tidy_style()
setwd("~/plugins/DSPPlugins/build decon plugin")
rm(list = ls())
source("SpatialDecon_plugin.R")
load("test data/2.0.0.89 Dev1 M-275 NGS CTAx4.RData")
# run it:
main(
dataset = dataset,
segmentAnnotations = segmentAnnotations,
targetAnnotations = targetAnnotations,
outputFolder = "testresults"
)
rm(list = ls())
source("SpatialDecon_plugin.R")
setwd("~/")
setwd("~/plugins/DSPPlugins/build decon plugin")
rm(list = ls())
source("SpatialDecon_plugin.R")
load("C:/Users/pdanaher/Downloads/Rdata export result - 2020-10-14 22_11_31.553 export.RData")
ls()
#### preliminaries ----------------------
dataset <- as.matrix(dataset)
# access cell profile matrix file:
X <- as.matrix(read.csv(cell_profile_filename, header = T, row.names = 1))
# parse merges:
merges.full <- NULL
if (length(merges) > 0) {
# initialize with 1:1 mapping:
merges.full <- list()
for (name in colnames(X)) {
merges.full[[name]] <- name
}
# add merges:
for (name in names(merges0)) {
# remove entries for cells specified by user and replace with their entries:
merges.full[merges[[name]]] <- NULL
merges.full[[name]] <- merges[[name]]
}
}
# parse nuclei column
cell_counts <- NULL
if (is.element(nuclei_count_column_name, colnames(segmentAnnotations))) {
cell_counts <- as.numeric(segmentAnnotations[, nuclei_count_column_name])
}
if (!is.element(nuclei_count_column_name, colnames(segmentAnnotations))) {
warning("The value entered for nuclei_count_column_name was not a column header in the segment annotations.
Results will not be output on the scale of cell counts; just in abundance scores and proportions.")
}
# parse pure tumor column
is_pure_tumor <- NULL
if (is.element(pure_tumor_column_name, colnames(segmentAnnotations))) {
is_pure_tumor <- segmentAnnotations[, pure_tumor_column_name] == "tumor"
is_pure_tumor <- replace(is_pure_tumor, is.na(is_pure_tumor), FALSE)
}
if (!is.element(pure_tumor_column_name, colnames(segmentAnnotations)) & (pure_tumor_column_name != "none")) {
warning("The value entered for pure_tumor_column_name was not a column header in the segment annotations.")
}
# format data for spatialdecon:
norm <- dataset[targetAnnotations$TargetGUID, segmentAnnotations$segmentID]
rownames(norm) <- targetAnnotations$TargetName
# calculate background:
bg <- derive_GeoMx_background(
norm = norm,
probepool = targetAnnotations$ProbePool,
negnames = targetAnnotations$TargetName[targetAnnotations$CodeClass == "Negative"]
)
#### run decon: ----------------------------------------
# decon:
res <- spatialdecon(
norm = norm,
bg = bg,
X = X,
is_pure_tumor = is_pure_tumor,
cell_counts = cell_counts,
cellmerges = merges.full
)
# Specify the filename of the cell profile matrix:
# Instructions: specifying a new cell profile matrix:
#   Use a .csv file with cell-type-specific expression profiles, with genes in
#   rows and cell types in columns. Row names should be in HUGO gene names.
# Instructions: downloading a pre-specified cell profile matrix:
#   You can supply your own cell profile matrix, or you can download a pre-specified one from
#   https://github.com/Nanostring-Biostats/Extensions/cell-profile-library
# Instructions: uploading to DSPDA:
#   Upload this csv file as you would a plugin .R file.
cell_profile_filename <- "safeTME-for-tumor-immune.csv"
# if you have segments selected to be pure tumor, free of immune and stroma,
# then specify a column name giving the identities of those segments. The
# code expects this column to have"tumor" entered for those segments, and other
# values elsewhere.
pure_tumor_column_name <- "none"
# enter the name of the column giving nuclei counts
nuclei_count_column_name <- "AOINucleiCount"
# define cell types to be added together in the final result:
# example syntax:
# merges = list()
# merges[["T"]] = c("CD8.T", "CD4.T")
# merges[["myeloid"]] = c("macrophage", "monocyte", "DC")
merges <- list()
# define variables to show in heatmaps:
variables_to_plot <- c("ScanName", "SegmentName")
# define coloring (optional):
# for a list of R colors, see http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf
# example syntax:
# cols <- list(ScanName = c("5911 CTA" = "red",
#                          "5917 CTA" = "blue",
#                          "5922 CTA" = "darkblue",
#                          "5929 CTA" = "forestgreen"),
#            SegmentName = c("Tumor" = "chartreuse3",
#                            "TME" = "dodgerblue3"))
cols <- NULL
# define which variables specify xy coordinates:
xpositionname <- "ROICoordinateX"
ypositionname <- "ROICoordinateY"
tissueidname <- "ScanName"
library(logNormReg)
library(pheatmap)
library(viridis)
#### preliminaries ----------------------
dataset <- as.matrix(dataset)
# access cell profile matrix file:
X <- as.matrix(read.csv(cell_profile_filename, header = T, row.names = 1))
# parse merges:
merges.full <- NULL
if (length(merges) > 0) {
# initialize with 1:1 mapping:
merges.full <- list()
for (name in colnames(X)) {
merges.full[[name]] <- name
}
# add merges:
for (name in names(merges0)) {
# remove entries for cells specified by user and replace with their entries:
merges.full[merges[[name]]] <- NULL
merges.full[[name]] <- merges[[name]]
}
}
# parse nuclei column
cell_counts <- NULL
if (is.element(nuclei_count_column_name, colnames(segmentAnnotations))) {
cell_counts <- as.numeric(segmentAnnotations[, nuclei_count_column_name])
}
if (!is.element(nuclei_count_column_name, colnames(segmentAnnotations))) {
warning("The value entered for nuclei_count_column_name was not a column header in the segment annotations.
Results will not be output on the scale of cell counts; just in abundance scores and proportions.")
}
# parse pure tumor column
is_pure_tumor <- NULL
if (is.element(pure_tumor_column_name, colnames(segmentAnnotations))) {
is_pure_tumor <- segmentAnnotations[, pure_tumor_column_name] == "tumor"
is_pure_tumor <- replace(is_pure_tumor, is.na(is_pure_tumor), FALSE)
}
if (!is.element(pure_tumor_column_name, colnames(segmentAnnotations)) & (pure_tumor_column_name != "none")) {
warning("The value entered for pure_tumor_column_name was not a column header in the segment annotations.")
}
# format data for spatialdecon:
norm <- dataset[targetAnnotations$TargetGUID, segmentAnnotations$segmentID]
rownames(norm) <- targetAnnotations$TargetName
# calculate background:
bg <- derive_GeoMx_background(
norm = norm,
probepool = targetAnnotations$ProbePool,
negnames = targetAnnotations$TargetName[targetAnnotations$CodeClass == "Negative"]
)
#### run decon: ----------------------------------------
# decon:
res <- spatialdecon(
norm = norm,
bg = bg,
X = X,
is_pure_tumor = is_pure_tumor,
cell_counts = cell_counts,
cellmerges = merges.full
)
# parse the argument for variables to plot:
if (length(setdiff(variables_to_plot, colnames(segmentAnnotations))) > 0) {
warning(paste0(
"the variables_to_plot values",
paste0(setdiff(variables_to_plot, colnames(segmentAnnotations)), collapse = ", "),
" are not present in the segmentAnnotations"
))
}
variables_to_plot <- intersect(variables_to_plot, colnames(segmentAnnotations))
heatmapannot <- NULL
if (length(variables_to_plot) > 0) {
heatmapannot <- segmentAnnotations[, variables_to_plot, drop = FALSE]
rownames(heatmapannot) <- colnames(res$beta)
# rownames(heatmapannot) <- segmentAnnotations$segmentDisplayName
}
# colors for variables_to_plot:
if (length(cols) == 0) {
cols <- assign_colors(segmentAnnotations[, variables_to_plot])
}
# show just the original cells, not tumor abundance estimates derived from the is.pure.tumor argument:
cells.to.plot <- intersect(rownames(res$beta), union(colnames(X), names(merges.full)))
heatmapannot
# colors for variables_to_plot:
if (length(cols) == 0) {
cols <- assign_colors(segmentAnnotations[, variables_to_plot])
}
cols
# show just the original cells, not tumor abundance estimates derived from the is.pure.tumor argument:
cells.to.plot <- intersect(rownames(res$beta), union(colnames(X), names(merges.full)))
#### heatmaps
# abundances:
thresh <- signif(quantile(res$beta, 0.97), 2)
p1 <- pheatmap(pmin(res$beta[cells.to.plot, ], thresh),
col = colorRampPalette(c("white", "darkblue"))(100),
fontsize_col = 4,
annotation_col = heatmapannot,
annotation_colors = cols,
legend_breaks = c(round(seq(0, thresh, length.out = 5))[-5], thresh),
legend_labels = c(round(seq(0, thresh, length.out = 5))[-5], paste0("Abundance scores,\ntruncated above at ", thresh))
# main = paste0("Abundance scores, truncated above at ", thresh)
)
print(p1)
# scaled abundances:
mat <- sweep(res$beta, 1, apply(res$beta, 1, max), "/")
p3 <- pheatmap(mat,
col = colorRampPalette(c("white", "darkblue"))(100),
fontsize_col = 4,
annotation_col = heatmapannot,
annotation_colors = cols,
legend_breaks = c(round(seq(0, 1, length.out = 5), 2)[-5], 1),
legend_labels = c(round(seq(0, 1, length.out = 5), 2)[-5], "Ratio to max\nabundance")
# main = paste0("Abundance scores, truncated above at ", thresh)
)
sum(is.na(mat))
